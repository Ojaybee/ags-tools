# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AGSTools
								 A QGIS plugin
 This plugin parses an AGS file and creates an SQlite database from it
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin                : 2023-04-19
		copyright            : (C) 2023 by Oliver Burdekin / burdGIS
		email                : info@burdgis.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Oliver Burdekin / burdGIS'
__date__ = '2023-04-19'
__copyright__ = '(C) 2024 by Oliver Burdekin / burdGIS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QSettings, QVariant
from qgis.core import (QgsProcessing,
					   QgsFeatureSink,
					   QgsApplication,
					   QgsMapLayer,
					   QgsProcessingAlgorithm,
					   QgsProcessingParameterFile,
					   QgsProcessingParameterFileDestination,
					   QgsProcessingParameterCrs,
					   QgsCoordinateReferenceSystem,
					   QgsDataSourceUri,
					   QgsVectorLayer,
					   QgsVectorLayer,
					   QgsField,
					   QgsFields,
					   QgsFeature,
					   QgsGeometry,
					   QgsPointXY,
					   QgsWkbTypes,
					   QgsVectorFileWriter,
					   QgsProject,
						)
from qgis.utils import iface
from io import StringIO
# import sqlite3
import os


class AGS2DBAlgorithm(QgsProcessingAlgorithm):
	"""
	This is an example algorithm that takes a vector layer and
	creates a new identical one.

	It is meant to be used as an example of how to create your own
	algorithms and explain methods and variables used to do it. An
	algorithm like this will be available in all elements, and there
	is not need for additional work.

	All Processing algorithms should extend the QgsProcessingAlgorithm
	class.
	"""

	# Constants used to refer to parameters and outputs. They will be
	# used when calling the algorithm from another algorithm, or when
	# calling from the QGIS console.

	OUTPUT = 'OUTPUT'
	INPUT = 'INPUT'
	CRS = 'CRS'

	def initAlgorithm(self, config):
		"""
		Here we define the inputs and output of the algorithm, along
		with some other properties.
		"""

		# We add the input vector features source. It can have any kind of
		# geometry.
		self.addParameter(
			QgsProcessingParameterFile(
				self.INPUT,
				self.tr('Input File'),
			)
		)

		# We add a feature sink in which to store our processed features (this
		# usually takes the form of a newly created vector layer when the
		# algorithm is run in QGIS).
		self.addParameter(
			QgsProcessingParameterFileDestination(
				self.OUTPUT,
				self.tr('Output Geopackage'),
				'Geopackage (*.gpkg)',
			)
		)

		self.addParameter(
			QgsProcessingParameterCrs(
				self.CRS,
				'Coordinate Reference System',
				defaultValue=QgsCoordinateReferenceSystem('EPSG:27700')
			)
		)

	def parse_ags_file(self, file_contents):
		lines = file_contents.split('\n')
		data = {}
		current_group = None
		headers = []

		# Takenn from AGS4 py
		for line in lines:
			if not line:
				continue

			temp = line.strip().split('","')
			temp = [item.strip('"') for item in temp]

			if temp[0] == 'GROUP':
				current_group = temp[1]
				data[current_group] = []
			elif temp[0] == 'HEADING':
				headers = temp[1:]
			elif temp[0] == 'UNIT':
				unit_values = temp[1:]
				if not any(unit_values):  # Skip empty UNIT rows
					unit_values = None
				else:
					data[f"{current_group}_units"] = dict(zip(headers, unit_values))
			elif temp[0] == 'DATA':
				record = dict(zip(headers, temp[1:]))
				data[current_group].append(record)

		# Detect column types for each group independently
		column_types = {}
		for group_name, records in data.items():
			if group_name.endswith("_units"):
				continue

			if records:
				# Use the first record's keys as headers for this group
				group_headers = list(records[0].keys())
				column_types[group_name] = {}
				for header in group_headers:
					all_numeric = all(self.is_numeric(record.get(header)) for record in records if record.get(header))
					if all_numeric:
						# If all values are numeric, use REAL type
						column_types[group_name][header] = "REAL"
					else:
						# Otherwise, default to TEXT type
						column_types[group_name][header] = "TEXT"

		return data, column_types
	
	def is_numeric(self, value):
		"""Utility function to check if value can be converted to a number."""
		try:
			float(value)
			return True
		except ValueError:
			return False
	
	def read_ags_file(self, file_path):
		with open(file_path, 'r') as file:
			file_contents = file.read()

		return file_contents

	def create_spatial_table_from_loca(self, cursor, group_name, records, x_column, y_column, srid):
		columns = list(records[0].keys())
		group_name = group_name.lower()
		create_table_sql = f"CREATE TABLE {group_name}_spatial (id INTEGER PRIMARY KEY, geom GEOMETRY, {', '.join([f'{column} TEXT' for column in columns])})"
		cursor.execute(create_table_sql)

		register_sql = f"""
		INSERT INTO geometry_columns (f_table_name, f_geometry_column, geometry_type, coord_dimension, srid, spatial_index_enabled)
		VALUES ('{group_name}_spatial', 'geom', 1, 2, {srid}, 0)
		"""
		cursor.execute(register_sql)

		create_spatial_index_sql = f"SELECT CreateSpatialIndex('{group_name}_spatial', 'geom')"
		cursor.execute(create_spatial_index_sql)

		for record in records:
			if record[x_column] and record[y_column]:
				x = float(record[x_column])
				y = float(record[y_column])
				values = [record[column] for column in columns]
				insert_sql = f"INSERT INTO {group_name}_spatial ({', '.join(columns)}, geom) VALUES ({', '.join(['?' for _ in columns])}, MakePoint(?, ?, {srid}))"
				cursor.execute(insert_sql, (*values, x, y))
			else:
				values = [record[column] for column in columns]
				insert_sql = f"INSERT INTO {group_name}_spatial ({', '.join(columns)}, geom) VALUES ({', '.join(['?' for _ in columns])}, NULL)"
				cursor.execute(insert_sql, values)

	def processAlgorithm(self, parameters, context, feedback):
		input_path = self.parameterAsFile(parameters, self.INPUT, context)
		output_path = self.parameterAsFileOutput(parameters, self.OUTPUT, context)
		crs = self.parameterAsCrs(parameters, self.CRS, context)

		# Read and parse the .ags file
		file_contents = self.read_ags_file(input_path)
		parsed_data, column_type_map = self.parse_ags_file(file_contents)

		# Remove existing GeoPackage if it exists
		if os.path.exists(output_path):
			os.remove(output_path)

		# Process each group and create layers
		for group_name, records in parsed_data.items():
			if not records:
				continue  # Skip if no records

			# Define fields based on detected column types
			fields = QgsFields()
			for column in records[0].keys():
				if column_type_map[group_name][column] == 'REAL':
					fields.append(QgsField(column, QVariant.Double))
				else:
					fields.append(QgsField(column, QVariant.String))

		# Determine geometry type
		if group_name == 'LOCA':
			geometry_type = QgsWkbTypes.Point
			layer_crs = crs
		else:
			geometry_type = QgsWkbTypes.NoGeometry
			layer_crs = None

		# Create an in-memory layer
		layer = QgsVectorLayer(
			f'{QgsWkbTypes.displayString(geometry_type)}?crs={layer_crs.authid() if layer_crs else ""}',
			group_name,
			'memory'
		)
		layer.dataProvider().addAttributes(fields)
		layer.updateFields()

		# Create features
		features = []
		for record in records:
			feature = QgsFeature()
			feature.setFields(fields)
			for column in record:
				value = record[column]
				if column_type_map[group_name][column] == 'REAL' and value:
					feature[column] = float(value)
				else:
					feature[column] = value

			# Set geometry for spatial layers
			if group_name == 'LOCA' and record.get('LOCA_NATE') and record.get('LOCA_NATN'):
				try:
					x = float(record['LOCA_NATE'])
					y = float(record['LOCA_NATN'])
					point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
					feature.setGeometry(point)
				except ValueError:
					pass  # Handle invalid coordinate values

			features.append(feature)

		# Add features to the layer
		layer.dataProvider().addFeatures(features)

		# Prepare options for writing to GeoPackage
		options = QgsVectorFileWriter.SaveVectorOptions()
		options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
		options.driverName = 'GPKG'
		options.layerName = group_name
		options.fileEncoding = 'UTF-8'

		if geometry_type != QgsWkbTypes.NoGeometry:
			options.layerOptions = [f'SRID={crs.authid().split(":")[1]}']
		else:
			options.layerOptions = ['GEOMETRY=None']

		# Write the layer to the GeoPackage
		error = QgsVectorFileWriter.writeAsVectorFormatV2(
			layer,
			output_path,
			context.transformContext(),
			options
		)

		if error[0] != QgsVectorFileWriter.NoError:
			feedback.reportError(f'Error writing {group_name} to GeoPackage: {error[1]}')

		# Load the 'LOCA' layer into QGIS
		loca_layer_uri = f'{output_path}|layername=LOCA'
		loca_layer = QgsVectorLayer(loca_layer_uri, 'LOCA', 'ogr')
		if not loca_layer.isValid():
			feedback.reportError('Failed to load LOCA layer')
		else:
			QgsProject.instance().addMapLayer(loca_layer)
			# Apply style if needed
		# Return the output path
		return {self.OUTPUT: output_path}
	
	def processing_log(self, message):
		"""
		Logs a message to the Processing log.
		"""
		self.logMessage(message)

	def name(self):
		"""
		Returns the algorithm name, used for identifying the algorithm. This
		string should be fixed for the algorithm, and must not be localised.
		The name should be unique within each provider. Names should contain
		lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'AGS2DB'

	def displayName(self):
		"""
		Returns the translated algorithm name, which should be used for any
		user-visible display of the algorithm name.
		"""
		return self.tr(self.name())

	def group(self):
		"""
		Returns the name of the group this algorithm belongs to. This string
		should be localised.
		"""
		return self.tr(self.groupId())

	def groupId(self):
		"""
		Returns the unique ID of the group this algorithm belongs to. This
		string should be fixed for the algorithm, and must not be localised.
		The group id should be unique within each provider. Group id should
		contain lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return ''

	def tr(self, string):
		return QCoreApplication.translate('Processing', string)

	def createInstance(self):
		return AGS2DBAlgorithm()
