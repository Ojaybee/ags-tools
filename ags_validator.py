# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AGS2DB
								 A QGIS plugin
 This plugin parses an AGS file and creates an SQlite database from it
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin                : 2023-04-19
		copyright            : (C) 2023 by Oliver Burdekin / burdGIS
		email                : info@burdgis.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Oliver Burdekin / burdGIS'
__date__ = '2023-04-19'
__copyright__ = '(C) 2023 by Oliver Burdekin / burdGIS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QSettings, QUrl
from qgis.PyQt.QtNetwork import QNetworkRequest, QHttpMultiPart, QHttpPart
from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterFile,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterEnum,
    QgsBlockingNetworkRequest,
    # QgsApplication,  # uncomment if you use QGIS auth manager
)
import os

class AGSValidatorAlgorithm(QgsProcessingAlgorithm):
	"""
	This is the algorithm class for the AGS validator.
	"""

	# Define constants for the algorithm's parameters
	INPUT = 'INPUT'
	DICTIONARY = 'DICTIONARY'
	CHECKERS = 'CHECKERS'
	OUTPUT = 'OUTPUT'
	
	# Define constants for the dictionary choices and checker options
	DICTIONARY_OPTIONS = ['None', '4.0.3', '4.0.4', '4.1', '4.1.1']  
	DICTIONARY_ALIASES = {'None': 'v4_1_1','4.0.3': 'v4_0_3','4.0.4': 'v4_0_4','4.1': 'v4_1','4.1.1': 'v4_1_1'}
	CHECKER_OPTIONS = ['ags', 'bgs']  

	def initAlgorithm(self, config):
		"""
		Here we define the inputs and output of the algorithm, along
		with some other properties.
		"""

		# Define the inputs for the algorithm
		self.addParameter(
			QgsProcessingParameterFile(
				self.INPUT,
				self.tr("Input File"),
				behavior=QgsProcessingParameterFile.File,
				fileFilter="All files (*.*)"
			)
		)
		self.addParameter(
			QgsProcessingParameterEnum(
				self.DICTIONARY,
				self.tr("AGS version"),
				options=self.DICTIONARY_OPTIONS,
				defaultValue=0
			)
		)

		self.addParameter(
			QgsProcessingParameterEnum(
				self.CHECKERS,
				self.tr("Checkers"),
				options=self.CHECKER_OPTIONS,
				allowMultiple=True,
				defaultValue=0
			)
		)

		# Define the outputs for the algorithm
		self.addParameter(
			QgsProcessingParameterFileDestination(
				self.OUTPUT,
				self.tr("Output File"),
				fileFilter="Text files (*.txt)"
			)
		)

   
	def processAlgorithm(self, parameters, context, feedback):
		# Retrieve parameters
		file_path = self.parameterAsFile(parameters, self.INPUT, context)
		dictionary = self.DICTIONARY_OPTIONS[self.parameterAsEnum(parameters, self.DICTIONARY, context)]
		dictionary_alias = self.DICTIONARY_ALIASES[dictionary]
		checkers_selected_indices = self.parameterAsEnums(parameters, self.CHECKERS, context)
		checkers_selected = [self.CHECKER_OPTIONS[i] for i in checkers_selected_indices]
		output_file = self.parameterAsFileOutput(parameters, self.OUTPUT, context)

		file_name = os.path.basename(file_path)
		url = 'https://agsapi.bgs.ac.uk/validate/'
		fmt = 'text'

		# Read file
		with open(file_path, 'rb') as f:
			file_content = f.read()

		# --- Build multipart/form-data using QGIS/Qt ---
		from qgis.PyQt.QtCore import QUrl
		from qgis.PyQt.QtNetwork import QNetworkRequest, QHttpMultiPart, QHttpPart
		from qgis.core import QgsBlockingNetworkRequest

		mp = QHttpMultiPart(QHttpMultiPart.FormDataType)

		# std_dictionary
		part_std = QHttpPart()
		part_std.setHeader(QNetworkRequest.ContentDispositionHeader, 'form-data; name="std_dictionary"')
		part_std.setBody(dictionary_alias.encode('utf-8'))
		mp.append(part_std)

		# checkers[] (multiple fields with same name)
		for c in checkers_selected:
			p = QHttpPart()
			p.setHeader(QNetworkRequest.ContentDispositionHeader, 'form-data; name="checkers"')
			p.setBody(str(c).encode('utf-8'))
			mp.append(p)

		# fmt
		part_fmt = QHttpPart()
		part_fmt.setHeader(QNetworkRequest.ContentDispositionHeader, 'form-data; name="fmt"')
		part_fmt.setBody(fmt.encode('utf-8'))
		mp.append(part_fmt)

		# file upload
		part_file = QHttpPart()
		part_file.setHeader(QNetworkRequest.ContentDispositionHeader,
							f'form-data; name="files"; filename="{file_name}"')
		part_file.setHeader(QNetworkRequest.ContentTypeHeader, 'text/plain')
		part_file.setBody(file_content)
		mp.append(part_file)

		# Fire POST via QGIS network stack (respects proxy/auth)
		req = QNetworkRequest(QUrl(url))
		bnr = QgsBlockingNetworkRequest()
		bnr.setTimeout(60000)  # 60s; adjust if needed

		ok = bnr.post(req, mp)

		# Handle network errors
		if (not ok) or bnr.error() != QgsBlockingNetworkRequest.NoError:
			msg = bnr.errorMessage()
			feedback.reportError(f'Error calling API: {msg}')
			raise Exception(f'Error calling API: {msg}')

		reply = bnr.reply()
		# ensure multipart lives until reply is done
		mp.setParent(reply)

		data = bytes(reply.readAll()).decode('utf-8', errors='replace')
		reply.deleteLater()

		# Write output file
		with open(output_file, 'w', encoding='utf-8') as f:
			f.write(data)

		feedback.pushInfo('API call was successful.')

		# Return outputs
		return {self.OUTPUT: output_file}

	
	def processing_log(self, message):
		"""
		Logs a message to the Processing log.
		"""
		self.logMessage(message)

	def name(self):
		"""
		Returns the algorithm name, used for identifying the algorithm. This
		string should be fixed for the algorithm, and must not be localised.
		The name should be unique within each provider. Names should contain
		lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'AGS validator'

	def displayName(self):
		"""
		Returns the translated algorithm name, which should be used for any
		user-visible display of the algorithm name.
		"""
		return self.tr(self.name())

	def group(self):
		"""
		Returns the name of the group this algorithm belongs to. This string
		should be localised.
		"""
		return self.tr(self.groupId())

	def groupId(self):
		"""
		Returns the unique ID of the group this algorithm belongs to. This
		string should be fixed for the algorithm, and must not be localised.
		The group id should be unique within each provider. Group id should
		contain lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return ''

	def tr(self, string):
		return QCoreApplication.translate('Processing', string)

	def createInstance(self):
		return AGSValidatorAlgorithm()
